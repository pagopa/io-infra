name: IO Platform SSL certificate renewal

#on:
#  schedule:
#    - cron: 0 0 * * *

on: 
  workflow_dispatch:
    inputs:
      force_renew_cert:
        description: "Force the certificate renewal"
        type: boolean
        required: true
        default: false
      python_version: 
        description: "Python version to use to run all the scripts"
        type: string
        required: true
        default: "3.12.8"


jobs:

  renewalDecision:

    runs-on: ubuntu-24.04
    
    steps:

      - name: Azure Login
        uses: azure/login@6b2456866fc08b011acb422a92a4aa20e2c4de32 # v2.1.0
        with:
          client-id: ${{ secrets.ARM_CLIENT_ID }}
          tenant-id: ${{ secrets.ARM_TENANT_ID }}
          subscription-id: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Fetch and check certificate
        run: |
                if [ ${{ inputs.force_renew_cert }} == "True" ]
                then
                  echo "${{ inputs.force_renew_cert }}"
                  echo "🔄 Parameter force_renew_cert is set to true"
                  exit 0
                fi
                if ! az keyvault certificate download --vault-name '$(KEY_VAULT_NAME)' -n '$(KEY_VAULT_CERT_NAME)' -f certificate.pem >/dev/null
                then
                  echo "require_new_certificate=true" >> $GITHUB_ENV"
                  echo "❌ The certificate was not found in the selected keyvault"
                  exit 0
                else
                  if ! openssl x509 -inform pem -checkend '$(CERT_NAME_EXPIRE_SECONDS)' -noout -in certificate.pem
                  then
                    # certificate is expiring or is already expired
                    echo "require_new_certificate=true" >> $GITHUB_ENV"
                  fi
                fi

      - name: Cleanup
        if: github.env.require_new_certificate == true
        run: rm -f certificate.pem

  getCertificateFromLE:

    runs-on: ubuntu-24.04
    needs: renewalDecision
    if: github.env.require_new_certificate == true

    steps:
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: inputs.python_version
      
      - name: Setup Python requirements
        run: |
            pip3 install --require-hashes --requirement requirements-output.txt
      
     # - name: Run CSR Python script
            #inputs:
             # scriptSource: filePath
              #scriptPath: generate_csr.py
              #arguments: --common-name $(csr_common_name) --out csr.der --rsa-key-size 2048

      - name: LE authentication keys to file 
        run: |
              targetType: "inline"
              script: |
                printf "%s\n" '$(LE_PRIVATE_KEY_JSON)' > private_key.json
                printf "%s\n" '$(LE_REGR_JSON)' > regr.json

      - name: Request new certificate from LE
        #with:
         #   AZURE_SUBSCRIPTION_ID: $(LE_AZURE_SUBSCRIPTION_ID)
          #  AZURE_IDENTITY_TYPE: $(LE_AZURE_IDENTITY_TYPE)
           # inputs:
            #  azureSubscription: "$(LE_SERVICE_CONNECTION)"
        run: "python3 acme_tiny.py --private-key private_key.json --regr regr.json --csr csr.der --out certificate_chain.pem"

      - name: Select Certificate
            #condition: and(succeeded(), eq(variables.require_new_certificate, True), ne(variables['alternate_chain_cn'], ''))
            #inputs:
              #azureSubscription: $(KEY_VAULT_SERVICE_CONNECTION)
              #scriptType: bash
              #scriptLocation: inlineScript
        run: |
                # by default the certificate_chain.pem.0 must be the selected certificate in case of no CN matches
                mv certificate_chain.pem.0 certificate_chain.pem
                # if we are not searching for a specific chain, exit early
                if [[ -z "$(alternate_chain_cn)" ]]; then
                  exit 0
                fi
                echo "🔍 Looking for $(alternate_chain_cn) root issuer..."
                for file in certificate_chain.pem.*; do
                  # assuming ordered PEMs in file
                  root_issuer=$(while openssl x509 -inform pem -noout -issuer 2>/dev/null; do :; done < "$file" | tail -n 1)
                  echo "🔍 The root issuer for $file is $root_issuer"
                  # check if the grep result is positive or not
                  if echo "$root_issuer" | sed 's/ *= */=/g' | grep '$(alternate_chain_cn)' 1>/dev/null
                  then
                    echo "✅ Found $(alternate_chain_cn) in $file!"
                    # print some debug info
                    while openssl x509 -inform pem -noout -issuer 2>/dev/null; do :; done < "$file"
                    # select this file
                    mv "$file" certificate_chain.pem
                    break
                  else
                    echo "⏭️ Skipping $file"
                  fi
                done
                
      - name: SelectCertificateDefault
            #condition: and(succeeded(), eq(variables.require_new_certificate, True), eq(variables['alternate_chain_cn'], ''))
            #inputs:
             # azureSubscription: $(KEY_VAULT_SERVICE_CONNECTION)
              #scriptType: bash
              #scriptLocation: inlineScript
        run: |
                # by default the certificate_chain.pem.0 must be the selected certificate in case of no CN matches
                mv certificate_chain.pem.0 certificate_chain.pem

      - name: SaveCertificateInKeyVault
            #condition: and(succeeded(), eq(variables.require_new_certificate, True))
            #inputs:
             # azureSubscription: $(KEY_VAULT_SERVICE_CONNECTION)
              #scriptType: bash
              #scriptLocation: inlineScript
        run: |
                echo "🚀 Creating pfx"
                openssl pkcs12 -inkey csr.key -in certificate_chain.pem -export -passout pass: -nodes -out certificate_chain.pfx
                echo "💾 Saving pfx in $(KEY_VAULT_NAME) with $(KEY_VAULT_CERT_NAME)"
                az keyvault certificate import --vault-name '$(KEY_VAULT_NAME)' -n '$(KEY_VAULT_CERT_NAME)' --disabled false -f certificate_chain.pfx --password "" --tags Force=${{ parameters.force_renew_cert }} >/dev/null

      - name: CleanupEverything
            #condition: always()
            #inputs:
             # targetType: "inline"
        run: |
                rm -f private_key.json
                rm -f regr.json
                rm -f csr.der
                rm -f csr.key
                rm -f certificate_chain.pem.*
                rm -f certificate_chain.pem
                rm -f certificate_chain.pfx
