name: SSL certificate renewal

#on:
#  schedule:
#    - cron: 0 0 * * *

on:
  workflow_dispatch:
    inputs:
      csr_common_name:
        description: "CSR common name"
        type: string
        required: true
      azure_subscription_id:
        description: "Azure Subscription id for all the platform resources"
        type: string
        required: true
      azure_dns_zone_resource_group:
        description: "Azure Resource Group that contains the target DNS zone"
        type: string
        required: true
      azure_dns_zone:
        description: "DNS zone for which we are renewing the certificate"
        type: string
        required: true
      key_vault_name:
        description: "Name of the Key Vault used to store the certificate"
        type: string
        required: true
      key_vault_cert_name:
        description: "Name to give to the stored certificated into the Key Vault"
        type: string
        required: true
      force_renew_cert:
        description: "Force the certificate renewal"
        type: boolean
        required: true
        default: false
      alternate_chain_cn:
        description: "Alternate CN for the certificate chain"
        type: string
        required: false

jobs:

  renewalDecision:

    runs-on: ubuntu-24.04
    environment: dev-ci
    permissions:
       id-token: write
    defaults:
      run:
        shell: bash
    env:
      certificate_expiration_time: "2592000" # Certificate expiration time in seconds, default to 30 days
    outputs:
      require_new_certificate: ${{ steps.fetch_and_check.outputs.require_new_certificate }}

    steps:

      - name: Azure Login
        uses: azure/login@6b2456866fc08b011acb422a92a4aa20e2c4de32 # v2.1.0
        with:
          client-id: ${{ secrets.ARM_CLIENT_ID }}
          tenant-id: ${{ secrets.ARM_TENANT_ID }}
          subscription-id: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Fetch and check certificate
        id: fetch_and_check
        run: |
            if [ ${{ inputs.force_renew_cert }} == "true" ]
              then
                echo "${{ inputs.force_renew_cert }}"
                echo "ðŸ”„ Parameter force_renew_cert is set to True"
            fi
            if ! az keyvault certificate download --vault-name '${{ inputs.key_vault_name }}' -n '${{ inputs.key_vault_cert_name }}' -f certificate.pem >/dev/null
              then
                echo "require_new_certificate=true" >> $GITHUB_OUTPUT
                echo "âŒ The certificate was not found in the selected keyvault"
            else
              if ! openssl x509 -inform pem -checkend '${{ env.certificate_expiration_time }}' -noout -in certificate.pem
                then
                  # certificate is expiring or is already expired
                  echo "do_cleanup=true" >> $GITHUB_ENV
                  echo "require_new_certificate=true" >> $GITHUB_OUTPUT
              fi
            fi

      - name: Cleanup
        if: env.do_cleanup == 'true'
        run: rm -f certificate.pem

  getCertificateFromLE:

    runs-on: ubuntu-24.04
    environment: dev-ci
    permissions:
       id-token: write
    needs: renewalDecision
    if: needs.renewalDecision.outputs.require_new_certificate == 'true'
    defaults:
      run:
        shell: bash
        working-directory: .github/workflows
    env:
      python_version: "3.12.8" # Python version to use to run all the scripts

    steps:

      - name: Check out the repository to run local scripts
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@6b2456866fc08b011acb422a92a4aa20e2c4de32 # v2.1.0
        with:
            client-id: ${{ secrets.ARM_CLIENT_ID }}
            tenant-id: ${{ secrets.ARM_TENANT_ID }}
            subscription-id: ${{ secrets.ARM_SUBSCRIPTION_ID }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.python_version }}
      
      - name: Setup Python requirements
        run: pip3 install --require-hashes --requirement requirements-output.txt

    # - name: Run CSR Python script
            #inputs:
            # scriptSource: filePath
              #scriptPath: generate_csr.py
              #arguments: --common-name $(csr_common_name) --out csr.der --rsa-key-size 2048

      - name: Run the python script to generate the CSR
        run: python3 ssl_certificate_renewal_generate_csr.py --common-name $(csr_common_name) --out csr.der --rsa-key-size 2048

      - name: LE authentication keys to file
        env:
          LE_PRIVATE_KEY_JSON: ${{ secrets.LE_PRIVATE_KEY_JSON }}
          LE_REGR_JSON: ${{ secrets.LE_REGR_JSON }}
        run: |
            printf "%s\n" '$(LE_PRIVATE_KEY_JSON)' > private_key.json
            printf "%s\n" '$(LE_REGR_JSON)' > regr.json

      - name: Request new certificate from LE
        env:
          AZURE_SUBSCRIPTION_ID: "${{ inputs.azure_subscription_id }}"
          AZURE_DNS_ZONE_RESOURCE_GROUP: "${{ inputs.azure_dns_zone_resource_group }}"
          AZURE_DNS_ZONE: "${{ inputs.azure_dns_zone }}"

        #with:
        #   AZURE_SUBSCRIPTION_ID: $(LE_AZURE_SUBSCRIPTION_ID)
          #  AZURE_IDENTITY_TYPE: $(LE_AZURE_IDENTITY_TYPE)
          # inputs:
            #  azureSubscription: "$(LE_SERVICE_CONNECTION)"

        run: "python3 acme_tiny.py --private-key private_key.json --regr regr.json --csr csr.der --out certificate_chain.pem"

      - name: Select Certificate

            #condition: and(succeeded(), eq(variables.require_new_certificate, True), ne(variables['alternate_chain_cn'], ''))
            #inputs:
              #azureSubscription: $(KEY_VAULT_SERVICE_CONNECTION)
              #scriptType: bash
              #scriptLocation: inlineScript

        run: |
            # by default the certificate_chain.pem.0 must be the selected certificate in case of no CN matches
            mv certificate_chain.pem.0 certificate_chain.pem
            # if we are not searching for a specific chain, exit early
            if [[ -z "${{ inputs.alternate_chain_cn }}" ]]; then
              exit 0
            fi
            echo "ðŸ” Looking for ${{ inputs.alternate_chain_cn }} root issuer..."
              for file in certificate_chain.pem.*; do
                # assuming ordered PEMs in file
                root_issuer=$(while openssl x509 -inform pem -noout -issuer 2>/dev/null; do :; done < "$file" | tail -n 1)
                echo "ðŸ” The root issuer for $file is $root_issuer"
                # check if the grep result is positive or not
                if echo "$root_issuer" | sed 's/ *= */=/g' | grep '${{ inputs.alternate_chain_cn }}' 1>/dev/null
                  then
                    echo "âœ… Found ${{ inputs.alternate_chain_cn }} in $file!"
                    # print some debug info
                    while openssl x509 -inform pem -noout -issuer 2>/dev/null; do :; done < "$file"
                    # select this file
                    mv "$file" certificate_chain.pem
                    break
                  else
                    echo "â­ï¸ Skipping $file"
                fi
              done
                
      - name: SelectCertificateDefault

            #condition: and(succeeded(), eq(variables.require_new_certificate, True), eq(variables['alternate_chain_cn'], ''))
            #inputs:
            # azureSubscription: $(KEY_VAULT_SERVICE_CONNECTION)
              #scriptType: bash
              #scriptLocation: inlineScript

        run: |
            # by default the certificate_chain.pem.0 must be the selected certificate in case of no CN matches
            mv certificate_chain.pem.0 certificate_chain.pem

      - name: SaveCertificateInKeyVault

            #condition: and(succeeded(), eq(variables.require_new_certificate, True))
            #inputs:
            # azureSubscription: $(KEY_VAULT_SERVICE_CONNECTION)
              #scriptType: bash
              #scriptLocation: inlineScript

        run: |
            echo "ðŸš€ Creating pfx"
            openssl pkcs12 -inkey csr.key -in certificate_chain.pem -export -passout pass: -nodes -out certificate_chain.pfx
            echo "ðŸ’¾ Saving pfx in ${{ inputs.key_vault_name }} with ${{ inputs.key_vault_cert_name }}"
            az keyvault certificate import --vault-name '${{ inputs.key_vault_name }}' -n '${{ inputs.key_vault_cert_name }}' --disabled false -f certificate_chain.pfx --password "" --tags Force=${{ inputs.force_renew_cert }} >/dev/null

      - name: CleanupEverything

            #condition: always()
            #inputs:
            # targetType: "inline"

        run: |
            rm -f private_key.json
            rm -f regr.json
            rm -f csr.der
            rm -f csr.key
            rm -f certificate_chain.pem.*
            rm -f certificate_chain.pem
            rm -f certificate_chain.pfx
